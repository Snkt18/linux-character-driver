#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define TFTP_PORT 69
#define BUFFER_SIZE 516
#define BLOCK_SIZE 512

enum Opcode { RRQ = 1, WRQ, DATA, ACK, ERROR };

int createSocket(sockaddr_in &serverAddr, const std::string &ip) {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(TFTP_PORT);
    inet_pton(AF_INET, ip.c_str(), &serverAddr.sin_addr);

    // Timeout: 3 sec
    struct timeval timeout = {3, 0};
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

    return sock;
}

void sendRequest(int sock, sockaddr_in &serverAddr, int opcode, const std::string &filename) {
    char buffer[BUFFER_SIZE];
    int len = 0;

    buffer[len++] = 0;
    buffer[len++] = opcode;
    strcpy(buffer + len, filename.c_str());
    len += filename.length() + 1;
    strcpy(buffer + len, "octet");
    len += 6; // "octet" + \0

    sendto(sock, buffer, len, 0, (sockaddr*)&serverAddr, sizeof(serverAddr));
}

void downloadFile(int sock, sockaddr_in serverAddr, const std::string &filename) {
    std::ofstream file(filename, std::ios::binary);
    if (!file) {
        std::cerr << "Cannot open file for writing.\n";
        return;
    }

    uint16_t expectedBlock = 1;
    socklen_t len = sizeof(serverAddr);
    char buffer[BUFFER_SIZE];

    while (true) {
        int retries = 0;
        while (retries < 3) {
            int bytes = recvfrom(sock, buffer, BUFFER_SIZE, 0, (sockaddr*)&serverAddr, &len);
            if (bytes >= 4 && buffer[1] == DATA) {
                uint16_t block = (buffer[2] << 8) | buffer[3];
                if (block == expectedBlock) {
                    file.write(buffer + 4, bytes - 4);
                    char ack[4] = {0, ACK, buffer[2], buffer[3]};
                    sendto(sock, ack, 4, 0, (sockaddr*)&serverAddr, len);
                    expectedBlock++;
                    break;
                }
            }
            retries++;
        }

        if (retries == 3) {
            std::cerr << "Download timed out.\n";
            break;
        }

        if (bytes < 516) break; // Last block
    }

    file.close();
}

void uploadFile(int sock, sockaddr_in serverAddr, const std::string &filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        std::cerr << "Cannot open file for reading.\n";
        return;
    }

    char buffer[BUFFER_SIZE];
    socklen_t len = sizeof(serverAddr);

    // Wait for ACK 0
    int bytes = recvfrom(sock, buffer, BUFFER_SIZE, 0, (sockaddr*)&serverAddr, &len);
    if (bytes < 4 || buffer[1] != ACK || (buffer[2] != 0 || buffer[3] != 0)) {
        std::cerr << "No ACK for WRQ\n";
        return;
    }

    uint16_t block = 1;
    while (!file.eof()) {
        buffer[0] = 0; buffer[1] = DATA;
        buffer[2] = block >> 8; buffer[3] = block & 0xFF;
        file.read(buffer + 4, BLOCK_SIZE);
        int dataLen = file.gcount();

        int retries = 0;
        while (retries < 3) {
            sendto(sock, buffer, dataLen + 4, 0, (sockaddr*)&serverAddr, len);
            int ackBytes = recvfrom(sock, buffer, BUFFER_SIZE, 0, (sockaddr*)&serverAddr, &len);
            if (ackBytes >= 4 && buffer[1] == ACK &&
                buffer[2] == (block >> 8) && buffer[3] == (block & 0xFF)) {
                break;
            }
            retries++;
        }

        if (retries == 3) {
            std::cerr << "Upload failed: No ACK\n";
            break;
        }

        if (dataLen < BLOCK_SIZE) break;
        block++;
    }

    file.close();
}

int main(int argc, char* argv[]) {
    if (argc != 5) {
        std::cerr << "Usage: ./tftp_client <server_ip> <get|put> <filename> <save_as>\n";
        return 1;
    }

    std::string serverIP = argv[1];
    std::string command = argv[2];
    std::string filename = argv[3];
    std::string outputName = argv[4];

    sockaddr_in serverAddr;
    int sock = createSocket(serverAddr, serverIP);

    if (command == "get") {
        sendRequest(sock, serverAddr, RRQ, filename);
        downloadFile(sock, serverAddr, outputName);
    } else if (command == "put") {
        sendRequest(sock, serverAddr, WRQ, filename);
        uploadFile(sock, serverAddr, filename);
    } else {
        std::cerr << "Invalid command.\n";
    }

    close(sock);
    return 0;
}
