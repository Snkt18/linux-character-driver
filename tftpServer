server.h 

#ifndef TFTP_SERVER_H
#define TFTP_SERVER_H

#include <winsock2.h>
#include <string>

class TFTPServer {
private:
    SOCKET sock;
    sockaddr_in serverAddr{}, clientAddr{};
    int clientLen;
    std::string rootDir;

public:
    TFTPServer(int port, const char* ftproot);
    void waitForReq();
    int receivePacket(char* buffer);
    void handleGetRequest(const std::string& filename);
    void handlePutRequest(const std::string& filename);
    void sendPacketData(uint16_t block, const char* data, int len);
    void sendAck(uint16_t block);
    void sendError(int error_no, const char* msg);
    void disconnectClient();
    ~TFTPServer();
};

#endif

server.cpp

#include "TFTPServer.h"
#include <iostream>
#include <fstream>

#pragma comment(lib, "Ws2_32.lib")

#define BUFFER_SIZE 516
#define BLOCK_SIZE 512
#define OPCODE_RRQ 1
#define OPCODE_WRQ 2
#define OPCODE_DATA 3
#define OPCODE_ACK 4
#define OPCODE_ERROR 5

TFTPServer::TFTPServer(int port, const char* ftproot) {
    rootDir = std::string(ftproot);
    WSAStartup(MAKEWORD(2, 2), new WSADATA());

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    bind(sock, (sockaddr*)&serverAddr, sizeof(serverAddr));

    int timeout = 3000;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));

    std::cout << "TFTP Server started at port " << port << "\n";
}

void TFTPServer::waitForReq() {
    while (true) {
        char buffer[BUFFER_SIZE];
        clientLen = sizeof(clientAddr);
        int bytes = recvfrom(sock, buffer, BUFFER_SIZE, 0,
                             (sockaddr*)&clientAddr, &clientLen);
        if (bytes < 4) continue;

        int opcode = buffer[1];
        std::string filename = std::string(buffer + 2);

        if (opcode == OPCODE_RRQ) handleGetRequest(filename);
        else if (opcode == OPCODE_WRQ) handlePutRequest(filename);
        else sendError(4, "Invalid request");
    }
}

int TFTPServer::receivePacket(char* buffer) {
    return recvfrom(sock, buffer, BUFFER_SIZE, 0, (sockaddr*)&clientAddr, &clientLen);
}

void TFTPServer::handleGetRequest(const std::string& filename) {
    std::ifstream file(rootDir + "/" + filename, std::ios::binary);
    if (!file) {
        sendError(1, "File not found");
        return;
    }

    char data[BUFFER_SIZE];
    uint16_t block = 1;

    while (!file.eof()) {
        file.read(data, BLOCK_SIZE);
        int readBytes = file.gcount();
        sendPacketData(block, data, readBytes);

        char ack[BUFFER_SIZE];
        int retries = 0;

        while (retries < 3) {
            int len = receivePacket(ack);
            if (len >= 4 && ack[1] == OPCODE_ACK &&
                ack[2] == (block >> 8) && ack[3] == (block & 0xFF)) break;
            retries++;
        }

        if (retries == 3) {
            sendError(0, "Timeout waiting for ACK");
            return;
        }

        if (readBytes < BLOCK_SIZE) break;
        block++;
    }

    file.close();
}

void TFTPServer::handlePutRequest(const std::string& filename) {
    std::ofstream file(rootDir + "/" + filename, std::ios::binary);
    if (!file) {
        sendError(2, "Cannot create file");
        return;
    }

    sendAck(0);
    uint16_t block = 1;
    char buffer[BUFFER_SIZE];

    while (true) {
        int bytes = receivePacket(buffer);
        if (bytes < 4 || buffer[1] != OPCODE_DATA) break;

        uint16_t recvBlock = (buffer[2] << 8) | buffer[3];
        if (recvBlock == block) {
            file.write(buffer + 4, bytes - 4);
            sendAck(block);
            if (bytes < 516) break;
            block++;
        }
    }

    file.close();
}

void TFTPServer::sendPacketData(uint16_t block, const char* data, int len) {
    char packet[BUFFER_SIZE] = {0};
    packet[1] = OPCODE_DATA;
    packet[2] = block >> 8;
    packet[3] = block & 0xFF;
    memcpy(packet + 4, data, len);
    sendto(sock, packet, len + 4, 0, (sockaddr*)&clientAddr, clientLen);
}

void TFTPServer::sendAck(uint16_t block) {
    char ack[4] = {0, OPCODE_ACK, static_cast<char>(block >> 8), static_cast<char>(block)};
    sendto(sock, ack, 4, 0, (sockaddr*)&clientAddr, clientLen);
}

void TFTPServer::sendError(int error_no, const char* msg) {
    char packet[BUFFER_SIZE] = {0};
    packet[1] = OPCODE_ERROR;
    packet[2] = 0;
    packet[3] = error_no;
    strcpy(packet + 4, msg);
    int len = strlen(msg);
    packet[4 + len] = 0;
    sendto(sock, packet, 5 + len, 0, (sockaddr*)&clientAddr, clientLen);
}

void TFTPServer::disconnectClient() {
    closesocket(sock);
}

TFTPServer::~TFTPServer() {
    disconnectClient();
    WSACleanup();
}

main.cpp

#include "TFTPServer.h"

int main() {
    TFTPServer server(69, "ftp_root");
    server.waitForReq();
    return 0;
}
