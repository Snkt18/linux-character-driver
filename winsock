#include <winsock2.h>
#include <iostream>
#include <fstream>
#include <string>

#pragma comment(lib, "Ws2_32.lib")

#define TFTP_PORT 69
#define OPCODE_RRQ 1
#define OPCODE_WRQ 2
#define OPCODE_DATA 3
#define OPCODE_ACK 4
#define OPCODE_ERROR 5
#define BLOCK_SIZE 512

SOCKET initSocket(sockaddr_in &serverAddr) {
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);

    SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(TFTP_PORT);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    bind(sock, (sockaddr*)&serverAddr, sizeof(serverAddr));
    return sock;
}

std::string parseFilename(const char* buffer, int length) {
    if (length < 4) return "";
    return std::string(buffer + 2);  // filename is right after 2-byte opcode
}

void sendError(SOCKET sock, sockaddr_in clientAddr, int errorCode, const std::string& message) {
    char errPacket[516];
    errPacket[0] = 0;
    errPacket[1] = OPCODE_ERROR;
    errPacket[2] = 0;
    errPacket[3] = errorCode;
    strcpy(errPacket + 4, message.c_str());
    int msgLen = message.length();
    errPacket[4 + msgLen] = 0;

    sendto(sock, errPacket, 5 + msgLen, 0, (sockaddr*)&clientAddr, sizeof(clientAddr));
}

void sendData(SOCKET sock, sockaddr_in clientAddr, const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        sendError(sock, clientAddr, 1, "File not found");
        return;
    }

    char dataPacket[516];
    uint16_t block = 1;
    socklen_t addrLen = sizeof(clientAddr);

    while (!file.eof()) {
        dataPacket[0] = 0;
        dataPacket[1] = OPCODE_DATA;
        dataPacket[2] = block >> 8;
        dataPacket[3] = block & 0xFF;

        file.read(dataPacket + 4, BLOCK_SIZE);
        int dataLen = file.gcount();

        sendto(sock, dataPacket, dataLen + 4, 0, (sockaddr*)&clientAddr, addrLen);

        // Wait for ACK
        char ack[4];
        int ackReceived = recvfrom(sock, ack, sizeof(ack), 0,
                                   (sockaddr*)&clientAddr, &addrLen);
        if (ackReceived < 4 || ack[1] != OPCODE_ACK) {
            std::cerr << "ACK not received for block " << block << "\n";
            break;
        }

        ++block;
        if (dataLen < BLOCK_SIZE) break;
    }

    file.close();
}

void receiveFile(SOCKET sock, sockaddr_in clientAddr, const std::string& filename) {
    std::ofstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        sendError(sock, clientAddr, 2, "Cannot create file");
        return;
    }

    // Send ACK for WRQ (block 0)
    char ack[4] = {0, OPCODE_ACK, 0, 0};
    sendto(sock, ack, 4, 0, (sockaddr*)&clientAddr, sizeof(clientAddr));

    char buffer[516];
    socklen_t addrLen = sizeof(clientAddr);
    uint16_t expectedBlock = 1;

    while (true) {
        int bytesReceived = recvfrom(sock, buffer, sizeof(buffer), 0,
                                     (sockaddr*)&clientAddr, &addrLen);

        if (bytesReceived >= 4 && buffer[1] == OPCODE_DATA) {
            uint16_t block = (buffer[2] << 8) | buffer[3];
            if (block == expectedBlock) {
                file.write(buffer + 4, bytesReceived - 4);
                ack[2] = buffer[2];
                ack[3] = buffer[3];
                sendto(sock, ack, 4, 0, (sockaddr*)&clientAddr, addrLen);
                expectedBlock++;
            }
            if (bytesReceived < 516) break;  // last block
        } else {
            sendError(sock, clientAddr, 4, "Unexpected packet");
            break;
        }
    }

    file.close();
}

int main() {
    sockaddr_in serverAddr{}, clientAddr{};
    SOCKET sock = initSocket(serverAddr);

    std::cout << "TFTP Server running on port 69...\n";

    while (true) {
        char buffer[516];
        int clientLen = sizeof(clientAddr);

        int bytesReceived = recvfrom(sock, buffer, sizeof(buffer), 0,
                                     (sockaddr*)&clientAddr, &clientLen);

        if (bytesReceived > 0) {
            uint8_t opcode = buffer[1];
            std::string filename = parseFilename(buffer, bytesReceived);

            if (opcode == OPCODE_RRQ) {
                std::cout << "[RRQ] " << filename << "\n";
                sendData(sock, clientAddr, filename);
            } else if (opcode == OPCODE_WRQ) {
                std::cout << "[WRQ] " << filename << "\n";
                receiveFile(sock, clientAddr, filename);
            } else {
                sendError(sock, clientAddr, 4, "Illegal operation");
            }
        }
    }

    closesocket(sock);
    WSACleanup();
    return 0;
}
